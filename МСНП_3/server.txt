#include <zmq.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <pcap.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
void packet_handler(u_char *user_data, const struct pcap_pkthdr *header, const u_char *packet) {
struct ether_header *eth_header = (struct ether_header *)packet;
if (ntohs(eth_header->ether_type) == ETHERTYPE_IP) {
const struct ip *ip_header = (struct ip *)(packet + sizeof(struct ether_header));
int ip_header_len = ip_header->ip_hl * 4; // Длина IP заголовка
char src_ip[INET_ADDRSTRLEN];
char dst_ip[INET_ADDRSTRLEN];
inet_ntop(AF_INET, &(ip_header->ip_src), src_ip, INET_ADDRSTRLEN);
inet_ntop(AF_INET, &(ip_header->ip_dst), dst_ip, INET_ADDRSTRLEN);
printf("Source IP: %s\n", src_ip);
printf("Destination IP: %s\n", dst_ip);
printf("IP Header Length: %d bytes\n", ip_header_len);
if (ip_header->ip_p == IPPROTO_TCP) {
const struct tcphdr *tcp_header = (struct tcphdr *)(packet + sizeof(struct ether_header) + ip_header_len);
int tcp_header_len = tcp_header->th_off * 4; // Длина TCP заголовка
const u_char *payload = packet + sizeof(struct ether_header) + ip_header_len + tcp_header_len;
int payload_len = ntohs(ip_header->ip_len) - (ip_header_len + tcp_header_len);
if (payload_len > 0) {
printf("Payload (%d bytes):\n", payload_len);
for (int i = 0; i < payload_len; i++) {
printf("%02x ", payload[i]);
if ((i + 1) % 16 == 0) {
printf("\n"); // Форматированный вывод по 16 байт в строке
}
}
printf("\n");
} else {
printf("No Payload\n");
}
}
}
}
int main (void) {
void *context = zmq_ctx_new();
void *responder = zmq_socket(context, ZMQ_REP);
int rc = zmq_bind(responder, "tcp://*:5555");
assert(rc == 0);
char errbuf[PCAP_ERRBUF_SIZE];
pcap_t *handle = pcap_open_live("lo", BUFSIZ, 1, 1000, errbuf); // Используем интерфейс lo для
тестирования
if (handle == NULL) {
fprintf(stderr, "Couldn't open device: %s\n", errbuf);
return 2;
}
while (1) {
char buffer[10];
zmq_recv(responder, buffer, 10, 0);
printf("\n");
struct pcap_pkthdr header;
const u_char *packet = pcap_next(handle, &header);
if (packet != NULL) {
printf("Captured a packet of length %d\n", header.len);
packet_handler(NULL, &header, packet); // Обрабатываем пакет
}
sleep(1); // Имитируем работу
zmq_send(responder, "World", 5, 0);
}
pcap_close(handle);
zmq_close(responder);
zmq_ctx_destroy(context);
return 0;
}
